# Copyright 2016, RadiantBlue Technologies, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use
# this file except in compliance with the License. You may obtain a copy of the
# License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software distributed
# under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
# CONDITIONS OF ANY KIND, either express or implied. See the License for the
# specific language governing permissions and limitations under the License.

import logging
import re
import uuid

import requests

from datetime import datetime
from bfapi import db
from bfapi.config import DOMAIN, GEOAXIS, GEOAXIS_CLIENT_ID, GEOAXIS_SECRET

TIMEOUT = 12
PATTERN_API_KEY = re.compile('^[a-f0-9]{32}$')


class User:
    def __init__(
            self,
            *,
            user_id: str,  # this is a unique ID, generated by Geoaxis
            name: str,
            api_key: str = None,
            created_on: datetime = None):
        self.user_id = user_id
        self.name = name
        self.api_key = api_key
        self.created_on = created_on


def authenticate_via_api_key(api_key: str) -> User:
    log = logging.getLogger(__name__)
    log.info('Users serv auth api key', action='Serv users auth api key')

    if not PATTERN_API_KEY.match(api_key):
        log.error('Cannot verify malformed API key: "%s"', api_key)
        raise MalformedAPIKey()

    log.debug('Checking "%s"', api_key)
    conn = db.get_connection()
    try:
        row = db.users.select_user_by_api_key(conn, api_key=api_key).fetchone()
    except db.DatabaseError as err:
        log.error('Database query for API key "%s" failed', api_key)
        db.print_diagnostics(err)
        raise
    finally:
        conn.close()

    if not row:
        log.error('Unauthorized API key "%s"', api_key)
        raise Unauthorized('Beachfront API key is not active')

    return User(
        user_id=row['user_id'],
        api_key=row['api_key'],
        name=row['user_name'],
        created_on=row['created_on'],
    )


def authenticate_via_geoaxis(auth_code: str) -> User:
    log = logging.getLogger(__name__)
    log.info('Users serv auth geoaxis', action='Serv users auth geoaxis')

    access_token = _request_geoaxis_access_token(auth_code)
    user_id, user_name = _fetch_geoaxis_profile(access_token)

    user = get_by_id(user_id)
    if not user:
        user = _create_user(user_id, user_name)

    log.info('User "%s" has logged in successfully', user_id, actor=user_id, action='logged in')

    return user


def get_by_id(user_id: str) -> User:
    log = logging.getLogger(__name__)
    log.info('Users serv get by id', action='Serv users get by id')

    log.debug('Searching database for user "%s"', user_id)
    conn = db.get_connection()
    try:
        row = db.users.select_user(conn, user_id=user_id).fetchone()
    except db.DatabaseError as err:
        log.error('Database query for user ID "%s" failed', user_id)
        db.print_diagnostics(err)
        raise
    finally:
        conn.close()

    if not row:
        return None

    return User(
        user_id=row['user_id'],
        api_key=row['api_key'],
        name=row['user_name'],
        created_on=row['created_on'],
    )


#
# Helpers
#

def _create_user(user_id, user_name) -> User:
    log = logging.getLogger(__name__)
    api_key = uuid.uuid4().hex

    log.info('Creating user account for "%s"', user_id, actor=user_id, action='create account')
    conn = db.get_connection()
    try:
        db.users.insert_user(
            conn,
            user_id=user_id,
            user_name=user_name,
            api_key=api_key,
        )
    except db.DatabaseError as err:
        log.error('Could not save user account "%s" to database', user_id)
        db.print_diagnostics(err)
        raise
    finally:
        conn.close()

    return User(
        user_id=user_id,
        name=user_name,
        api_key=api_key,
        created_on=datetime.utcnow(),
    )


def _fetch_geoaxis_profile(access_token: str):
    log = logging.getLogger(__name__)

    log.debug('Sending request: access_token="%s"', access_token)
    try:
        response = requests.get(
            'https://{}/ms_oauth/resources/userprofile/me'.format(GEOAXIS),
            timeout=TIMEOUT,
            headers={
                'Authorization': 'Bearer {}'.format(access_token),
            },
        )
        log.debug('Received response: %s', response.text)
        response.raise_for_status()
    except requests.ConnectionError as err:
        log.error('Could not reach GeoAxis: %s', err)
        raise GeoaxisUnreachable()
    except requests.HTTPError as err:
        status_code = err.response.status_code
        if status_code == 401:
            log.error('GeoAxis rejected access token: %s', err.response.text)
            raise Unauthorized('GeoAxis rejected access token')
        log.error('GeoAxis returned HTTP %s: %s', status_code, err.response.text)
        raise GeoaxisError(status_code)

    profile = response.json()

    user_id = profile.get('DN')
    if not user_id:
        log.error('Geoaxis response missing `DN`: %s', response.text)
        raise InvalidGeoaxisResponse('missing `DN`', response.text)

    name = profile.get('commonname')
    if not name:
        log.error('Geoaxis response missing `commonname`: %s', response.text)
        raise InvalidGeoaxisResponse('missing `commonname`', response.text)

    return user_id, name


def _request_geoaxis_access_token(auth_code: str):
    log = logging.getLogger(__name__)

    log.debug('Requesting: code="%s"', auth_code)
    try:
        response = requests.post(
            'https://{}/ms_oauth/oauth2/endpoints/oauthservice/tokens'.format(GEOAXIS),
            timeout=TIMEOUT,
            auth=(GEOAXIS_CLIENT_ID, GEOAXIS_SECRET),
            data={
                'grant_type': 'authorization_code',
                'code': auth_code,
                'redirect_uri': 'https://bf-api.{}/login'.format(DOMAIN),
            },
        )
        log.debug('Received response: %s', response.text)
        response.raise_for_status()
    except requests.ConnectionError as err:
        log.error('Could not reach GeoAxis: %s', err)
        raise GeoaxisUnreachable()
    except requests.HTTPError as err:
        status_code = err.response.status_code
        if status_code == 401:
            log.error('GeoAxis rejected user auth code: %s', err.response.text)
            raise Unauthorized('GeoAxis rejected auth code')
        log.error('GeoAxis returned HTTP %s: %s', status_code, err.response.text)
        raise GeoaxisError(status_code)

    access = response.json()
    access_token = access.get('access_token')
    if not access_token:
        log.error('Geoaxis response missing `access_token`.  Response Text:\n%s', response.text)
        raise InvalidGeoaxisResponse('missing `access_token`', response.text)
    return access_token


#
# Errors
#

class Error(Exception):
    def __init__(self, message: str):
        super().__init__(message)


class GeoaxisUnreachable(Error):
    def __init__(self):
        super().__init__('Geoaxis is unreachable')


class GeoaxisError(Error):
    def __init__(self, status_code: int):
        super().__init__('GeoAxis responded with HTTP {}'.format(status_code))
        self.status_code = status_code


class InvalidGeoaxisResponse(Error):
    def __init__(self, message: str, response_text: str):
        super().__init__('GeoAxis returned invalid response: ' + message)
        self.response_text = response_text


class MalformedAPIKey(Error):
    def __init__(self):
        super().__init__('Malformed API key')


class Unauthorized(Error):
    def __init__(self, message: str):
        super().__init__('Unauthorized: {}'.format(message))
